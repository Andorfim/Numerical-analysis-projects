# -*- coding: utf-8 -*-
"""LABA1NumbericMethods.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bURVgTRGODviBX5OAlYDN1uCOvpgKoEQ

Модули, отвечающие за выполнение алгоритмов подготовки изображений и генерации шума
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import convolve2d
import scipy.ndimage
from skimage.metrics import mean_squared_error
from PIL import Image
from PIL import ImageOps
import time

"""Функции алгоритмов восстановления"""

# Функция для генерации передаточной функции
def generate_psf(size, radius):
    psf = np.zeros(size)
    center = (size[0] // 2, size[1] // 2)
    y, x = np.ogrid[:size[0], :size[1]]
    psf[(x - center[0])**2 + (y - center[1])**2 <= radius**2] = 1
    return psf / np.sum(psf)  # Нормализация

# Функция для добавления гауссовского шума к изображению
def add_gaussian_noise(image, std_dev):
    noise = np.random.normal(0, std_dev, image.shape)
    noisy_image = image + noise
    return noisy_image

# Функция для восстановления изображения методом инверсии
def inverse_filter(noisy_image, psf, noise_var):
    # Вычисление спектра PSF
    psf_fft = np.fft.fft2(psf, noisy_image.shape)

    # Вычисление спектра зашумленного изображения
    noisy_image_fft = np.fft.fft2(noisy_image)

    # Восстановление изображения
    restored_image_fft = np.divide(noisy_image_fft, psf_fft + noise_var)
    restored_image = np.fft.ifft2(restored_image_fft).real

    return restored_image

# Функция для восстановления изображения методом регуляризации Тихонова
def tikhonov_regularization(noisy_image, psf, noise_var, alpha):
    # Вычисление спектра PSF
    psf_fft = np.fft.fft2(psf, noisy_image.shape)

    # Вычисление спектра зашумленного изображения
    noisy_image_fft = np.fft.fft2(noisy_image)

    # Регуляризация Тихонова
    regularization_term = np.conj(psf_fft) / (np.abs(psf_fft)**2 + alpha)

    # Восстановление изображения
    restored_image_fft = noisy_image_fft * regularization_term
    restored_image = np.fft.ifft2(restored_image_fft).real

    return restored_image

# Функция для восстановления изображения методом Люси-Ричардсона


def richardson_lucy(noisy_image, psf, iterations):

    restored_image = noisy_image.copy()
    psf_flip = np.flip(psf)
    mse = lambda img1, img2: mean_squared_error(img1, img2)

    for i in range(iterations):
      back = restored_image
      estimate = np.fft.ifft2(np.fft.fft2(restored_image) / np.fft.fft2(psf))
      # error - оценка изображения на итерации
      error = noisy_image / (estimate + np.finfo(float).eps)
      error = np.fft.ifft2(np.fft.fft2(error) / np.fft.fft2(psf_flip))
      restored_image *= error.real

      # остановка на моменте, когда следующие итерации дают малое изменения
      if mse(img1=back, img2=restored_image) <= 0.01:
        break

    return restored_image




# Функция для восстановления изображения методом фильтра Винера
def wiener_filter(noisy_image, psf, noise_var):
    # Вычисление спектра PSF
    psf_fft = np.fft.fft2(psf, noisy_image.shape)

    # Вычисление спектра зашумленного изображения
    noisy_image_fft = np.fft.fft2(noisy_image)

    # Фильтр Винера
    wiener_filter = np.conj(psf_fft) / (np.abs(psf_fft)**2 + noise_var)

    # Восстановление изображения
    restored_image_fft = noisy_image_fft * wiener_filter
    restored_image = np.fft.ifft2(restored_image_fft).real

    return restored_image

# Размер изображения и радиус PSF
filename = "/Users/andrejefimov/projects/chisl/norm.jpg"
original_image_pil = Image.open(filename)
original_image = np.array(ImageOps.grayscale(original_image_pil))



image_size = (256, 256)
psf_radius = 25

psf = generate_psf(image_size, psf_radius)

# Генерация PSF и добавление гауссовского шума
blurred_image = convolve2d(original_image, psf, 'same', 'wrap')

noise_std = 0.001
# дисперсия

noisy_image = add_gaussian_noise(blurred_image, noise_std)


# Параметры для регуляризации Тихонова
alpha = 1e-4





def mse(img1, img2):

  image1 = img1
  image2 = img2

  n = len(image1)
  m = len(image1[0])

  sum_of_squares = 0
  for i in range(n):
      for j in range(m):
          pixel_diff = image1[i][j] - image2[i][j]
          sum_of_squares += pixel_diff ** 2

  mean_square = sum_of_squares / (n * m)
  mse = mean_square ** 0.5

  return mse

"""Функция для сохранения изображений в среду Colab"""

def to_save(picture, name_image):
  img = picture
  width = 256

  if name_image != 'noisy_image':
    top_left = img[:width//2, :width//2]
    top_right = img[:width//2, width//2:]
    bottom_left = img[width//2:, :width//2]
    bottom_right = img[width//2:, width//2:]

    # Меняем участки местами
    # не знаю почему, но у меня менялись положения участков изображения

    new_img = np.zeros((width, width), dtype=np.uint8)
    new_img[:width//2, :width//2] = bottom_right
    new_img[:width//2, width//2:] = bottom_left
    new_img[width//2:, :width//2] = top_right
    new_img[width//2:, width//2:] = top_left

    restored_image_pil = Image.fromarray(new_img)
    restored_image_pil = restored_image_pil.convert("L")
    output_filename = f"{name_image}.jpg"
    restored_image_pil.save(output_filename)

  else:
    new_img = img

    restored_image_pil = Image.fromarray(new_img)
    restored_image_pil = restored_image_pil.convert("L")
    output_filename = f"{name_image}.jpg"
    restored_image_pil.save(output_filename)

"""Применение модулей (ща буит мясо)"""

def mse(img1, img2):

  image1 = img1
  image2 = img2

  n = len(image1)
  m = len(image1[0])

  sum_of_squares = 0
  for i in range(n):
      for j in range(m):
          pixel_diff = image1[i][j] - image2[i][j]
          sum_of_squares += pixel_diff ** 2

  mean_square = sum_of_squares / (n * m)
  mse = mean_square ** 0.5

  return mse




start_time = time.time()
restored_inverse = inverse_filter(noisy_image, psf, noise_std**2)
end_time = time.time()
print('Инверсная фильтрация:', end_time-start_time)
print('Среднеквадратичное отклонение', mse(img1=original_image, img2=restored_inverse))



start_time = time.time()
restored_tikhonov = tikhonov_regularization(noisy_image, psf, noise_std**2, alpha)
end_time = time.time()
print('Регуляризация Тихонова:', end_time-start_time)
print('Среднеквадратичное отклонение', mse(img1=original_image, img2=restored_tikhonov))


start_time = time.time()
restored_rl = richardson_lucy(noisy_image = noisy_image, psf = psf, iterations=100) #Количество итераций
end_time = time.time()
print('Ричарда-Люси:', end_time-start_time)
print('Среднеквадратичное отклонение', mse(img1=original_image, img2=restored_rl))


start_time = time.time()
restored_wiener = wiener_filter(noisy_image, psf, noise_std**2)
end_time = time.time()
print('Фильтр Винера:', end_time-start_time)
print('Среднеквадратичное отклонение', mse(img1=original_image, img2=restored_wiener))

"""Сохранение всех изображений"""

to_save(restored_inverse, 'restored_inverse')
to_save(restored_tikhonov, 'restored_tikhonov')
to_save(restored_rl, 'restored_rl')
to_save(restored_wiener, 'restored_wiener')


to_save(noisy_image, 'noisy_image')

